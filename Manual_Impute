import pandas as pd
import re
import os
from typing import Union

def process_excel_data(file_path: str) -> Union[pd.DataFrame, None]:
    """
    Loads an Excel file, removes specific T0 replicate columns (TM2A1_y and TM2An1_y),
    and then imputes missing values for each metabolite by calculating the row-wise
    average of its 5 replicates within the corresponding timepoint group.
    Imputation is applied to all remaining identified timepoint columns.

    The expected column format is 'TM2Ax_y' where 'x' is the timepoint identifier
    (e.g., 'A1', 'A2', 'An1', 'An2') and 'y' is the replicate number (1-5).

    Args:
        file_path (str): The full path to the input Excel file.

    Returns:
        pd.DataFrame or None: The processed DataFrame with T0 columns removed and
                               missing values imputed, or None if an error occurs.
    """
    if not os.path.exists(file_path):
        print(f"Error: File not found at '{file_path}'. Please ensure the path is correct.")
        return None

    try:
        df = pd.read_excel(file_path, na_values=['', ' ', '-', '#N/A', 'NULL', 'null'])
        print(f"Successfully loaded data from '{file_path}'.")
        print(f"Initial shape of DataFrame: {df.shape}")
        print(f"Initial count of NaN values: {df.isna().sum().sum()}")

    except Exception as e:
        print(f"Error loading Excel file: {e}")
        return None

    processed_df = df.copy()

    # --- 1. Identify and remove T0 columns (TM2A1_y and TM2An1_y) ---
    # Regex: Strictly matches 'TM2A1_y' or 'TM2An1_y' where y is 1-5.
    remove_t0_pattern = re.compile(r'TM2(A1|An1)_[1-5]$', re.IGNORECASE)

    columns_to_remove = [col for col in processed_df.columns if remove_t0_pattern.search(col)]

    if columns_to_remove:
        processed_df = processed_df.drop(columns=columns_to_remove, axis=1)
        print(f"\nSuccessfully removed {len(columns_to_remove)} T0 columns (TM2A1_y / TM2An1_y patterns).")
        print(f"Shape of DataFrame after T0 column removal: {processed_df.shape}")
    else:
        print("\nNo T0 columns (TM2A1_y / TM2An1_y patterns) were found for removal. No columns removed based on this criteria.")


    # --- 2. Impute missing values for all remaining timepoints ---
    timepoint_groups = {}
    # Regex to capture names like 'TM2A1_1', 'TM2A2_5', 'TM2An3_5' for grouping
    # Will only process non-T0 columns that match the pattern.
    timepoint_regex = re.compile(r'(TM2[A-Za-z]+\d+)_[1-5]$', re.IGNORECASE)

    # Populate timepoint_groups with all matching columns for imputation
    for col in processed_df.columns:
        match = timepoint_regex.match(col)
        if match:
            group_identifier = match.group(1)
            if group_identifier not in timepoint_groups:
                timepoint_groups[group_identifier] = []
            timepoint_groups[group_identifier].append(col)

    if not timepoint_groups:
        print("\nWarning: No timepoint groups were identified for imputation. Check column names and regex pattern after T0 removal.")
    else:
        print(f"\nIdentified {len(timepoint_groups)} timepoint groups for imputation.")

    nan_count_before_imputation = processed_df.isna().sum().sum()
    print(f"Number of NaN values before imputation: {nan_count_before_imputation}")

    # Iterate through each timepoint group and perform imputation
    imputed_groups_count = 0
    for group_id, cols_in_group in timepoint_groups.items():
        if not cols_in_group:
            continue

        # Ensure columns are numeric for mean calculation.
        for col_name in cols_in_group:
            processed_df[col_name] = pd.to_numeric(processed_df[col_name], errors='coerce')

        row_means_for_group = processed_df[cols_in_group].mean(axis=1, skipna=True)

        # Apply the imputation
        for col_name in cols_in_group:
            processed_df[col_name] = processed_df[col_name].fillna(row_means_for_group)
        imputed_groups_count += 1
    
    print(f"Successfully attempted imputation for {imputed_groups_count} timepoint groups.")

    nan_count_after_imputation = processed_df.isna().sum().sum()
    print(f"Number of NaN values after imputation: {nan_count_after_imputation}")
    
    if nan_count_after_imputation < nan_count_before_imputation:
        print("Imputation successfully reduced the number of missing values.")
    elif nan_count_after_imputation == nan_count_before_imputation and nan_count_before_imputation > 0:
        print("Imputation attempted but no NaN values were filled. This might indicate that all replicates in relevant groups were NaN for the affected rows.")
    else:
        print("No missing values were present or changed during imputation.")

    print("\nData processing and imputation complete.")
    return processed_df

# --- Example Usage ---
if __name__ == "__main__":
    input_file_path = "/YOUR/INPUT/FILE/PATH" 

    # Define the output file path for the processed data
    output_directory = os.path.dirname(input_file_path)
    output_file_name = "Manual_Impute.xlsx" 
    output_file_path = os.path.join(output_directory, output_file_name)

    # Process the data
    imputed_df = process_excel_data(input_file_path)

    if imputed_df is not None:
        try:
            imputed_df.to_excel(output_file_path, index=False)
            print(f"\nProcessed data successfully saved to: '{output_file_path}'")
        except Exception as e:
            print(f"Error saving processed data to Excel: {e}")
